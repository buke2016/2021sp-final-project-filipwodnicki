"""network.py

Network and its child classes live here (Walk, Transit, Multi)
"""

from contextlib import contextmanager

import geopandas as gpd
from shapely.geometry import Point
import pandas as pd
import osmnx as ox
import networkx as nx
import numpy as np
import peartree as pt
from networkx.readwrite import write_gpickle, read_gpickle

from .cartography import NetworkMapper
from .routing import RoutingMixin
from .merge import convert_length_to_meter


class Network(RoutingMixin):
    """
    General Network class. Its main job is to hold and provide convenient access to
    the networkx graph (generated by osmnx). It is not used directly. Instead, Network is
    inherited by: WalkNetwork, TransitNetwork, MultiNetwork.

    * Leverages RoutingMixin to provide route utilties.

    * Leverages NetworkMapper Descriptor to provide map utilities.

    Example:
        n = Network()
        n.mapper  # Folium map that can be saved or viewed directly in Jupyter Notebook
    """

    mapper = NetworkMapper()

    def __init__(self, G: nx.Graph):
        self.G = G

    def __getitem__(self, node_id):
        """Returns the Graph node adjacency view by subscripting"""
        return self.G[node_id]

    @property
    def nodes(self):
        """Get nodes by calling `Network.nodes`"""
        return self.G.nodes

    @property
    def edges(self):
        """Get graph edges by calling `Network.edges`"""
        return self.G.edges

    @property
    def nodes_df(self):
        """Get the network's nodes as a convenient DataFrame"""
        node_list = [
            {"id": node[0], "y": node[1]["y"], "x": node[1]["x"]}
            for node in list(self.G.nodes(data=True))
        ]
        return pd.DataFrame(node_list)

    @property
    def edges_df(self):
        """Get the network's edges as a convenient DataFrame"""
        return nx.convert_matrix.to_pandas_edgelist(self.G)

    @property
    def edges_with_nodes_df(self):
        """Get a combined Node+Edges dataframe of the Network's graph"""
        nodes_df = self.nodes_df
        edges_df = self.edges_df
        edges_df = edges_df.merge(nodes_df, left_on="source", right_on="id", how="left")
        edges_df = edges_df.merge(
            nodes_df,
            left_on="target",
            right_on="id",
            how="left",
            suffixes=("_source", "_target"),
        )
        return edges_df

    @property
    def extent_polygon(self):
        """Returns the geographic extent of the network via the convex hull method

        Code attribution: http://kuanbutts.com/2018/12/24/peartree-with-walk-network/"""
        boundary = gpd.GeoSeries(
            [Point(n["x"], n["y"]) for i, n in self.G.nodes(data=True)]
        ).unary_union.convex_hull
        return boundary

    @property
    def bounding_box(self):
        """returns the Upper Left and lower right bounding box of the Network bounds"""
        (minx, miny, maxx, maxy) = self.extent_polygon.bounds
        return [(maxy, maxx), (miny, minx)]

    @contextmanager
    def open_as_edges_df(self, nx_graph_constructor=nx.MultiDiGraph):
        """Context manager allowing you to conveniently work on the edges of the network
        without digging into the internals.

        Args:
            nx_graph_constructor (default=nx.MultiDiGraph):

        Usage:
            n = Network()
            with n.open_as_edges_df() as df:
                df # do something

        """
        try:
            df = self.edges_df
            yield df
        finally:
            print(f"Overwriting {self.G}")
            self.G = nx.convert_matrix.from_pandas_edgelist(
                df, edge_attr=True, create_using=nx_graph_constructor
            )

    @classmethod
    def load(cls, filepath):
        """Raises NotImplementedError. Instead, implemented in child classes"""
        raise NotImplementedError


class TransitNetwork(Network):
    """
    Transit specific network. Heavily based on Peartree.

    Usage:
        T = TransitNetwork.create_from_gtfs("data/MBTA_GTFS.zip")
    """

    mapper = NetworkMapper(
        color_by_col="mode", color_scheme={"transit": "blue"}, popup_info=["length"]
    )

    def __init__(self, graph):
        super().__init__(graph)
        # TODO Enforce schema

    @classmethod
    def create_from_gtfs(cls, gtfs_feed_zip):
        """Initialize TransitNetwork via standard Peartree method

        Args:
            gtfs_feed_zip (Path): path to GTFS zip file (including .zip extension)

        Returns:
            TransitNetwork
        """
        feed = pt.get_representative_feed(gtfs_feed_zip)
        start = 7 * 60 * 60
        end = 9 * 60 * 60
        graph = pt.load_feed_as_graph(feed, start, end)
        return cls(graph)

    @classmethod
    def load(cls, filepath):
        """Load a saved network"""
        graph = read_gpickle(filepath)
        return cls(graph)

    def save(self, fname):
        """Save the network. fname must have .pickle extension"""
        write_gpickle(self.G, fname)


class WalkNetwork(Network):
    """
    Walk flavor of the Network. Heavily based on osmnx methods

    Usage:
        W = WalkNetwork.create_from_name("Boston")
    """

    mapper = NetworkMapper(
        color_by_col=None, color_scheme=None, popup_info=["osmid", "name", "length"]
    )  # Uses the NetworkMapper color defaults.

    def __init__(self, graph):
        super().__init__(graph)
        # TODO Enforce schema

    @classmethod
    def load(cls, filepath):
        """Load a saved network. To be used in tandem with save.

        Args:
            filepath (Path): path to saved osmnx network in .graphml format

        Returns:
            WalkNetwork
        """
        graph = ox.io.load_graphml(filepath)
        return cls(graph)

    @classmethod
    def create_from_name(cls, place_name):
        """Build a osmnx graph from the Place name. Refer to osmnx docs for more details."""
        graph = ox.graph.graph_from_place(place_name, network_type="walk")
        return cls(graph)

    def save(self, fpath):
        """Save walk network to graphml object. Leverages osmnx method."""
        ox.io.save_graphml(self.G, filepath=fpath)


class MultiNetwork(TransitNetwork):
    """
    Combined Walk+Transit network flavor!

    Usage:
        W = WalkNetwork.create_from_name()
        T = TransitNetwork.create_from_gtfs()
        WT = MultiNetwork.combine(walk=W, transit=T)
    """

    mapper = NetworkMapper(
        color_by_col="mode",
        color_scheme={"transit": "blue", "walk": "darkgrey"},
        popup_info=["mode", "osmid", "length"],
    )

    def __init__(self, graph):
        super().__init__(graph)

    @classmethod
    def create_from_gtfs(cls, gtfs_feed_zip):
        """This method is supposed to fail because Combined network
        needs Transit (GTFS) network and walk network"""
        raise RuntimeError("Needs a walk network!")

    @classmethod
    def combine(cls, walk: WalkNetwork, transit: TransitNetwork):
        """Method to build a combined Walking + Transit (aka "Multi") Network

        Args:
            walk (WalkNetwork): The WalkNetwork of the city you're studying.
            transit (TransitNetwork): The TransitNetwork of the place you're studying

        Returns:
            MultiNetwork
        """

        # TODO refactor into smaller methods

        walk.G = convert_length_to_meter(walk.G)

        transit_nodes = ox.utils_graph.graph_to_gdfs(
            transit.G, edges=False, node_geometry=True
        )

        xarr = transit_nodes["x"].to_numpy()
        yarr = transit_nodes["y"].to_numpy()

        nodes, dist = walk.nearest_k_nodes(X=xarr, Y=yarr, k=1, return_dist=True)
        nodes_flat = np.array(nodes).reshape(len(nodes))
        dist_flat = np.array(dist).reshape(len(dist))

        transit_nodes = (
            transit_nodes.reset_index()
            .join(pd.Series(nodes_flat, name="nearest_node"))
            .join(pd.Series(dist_flat, name="dist"))
        )

        def convert_meters_to_seconds(m, kph=4.5):
            kilometers = m / 1000
            hours = kilometers / kph
            return hours * 60 * 60

        transit_nodes["time"] = transit_nodes["dist"].apply(convert_meters_to_seconds)

        G = nx.union(walk.G, transit.G)

        transit_tuples = [
            (row[0], row[6], dict(length=row[8], mode="walk"))
            for _, row in transit_nodes.iterrows()
        ]
        G.add_edges_from(transit_tuples)
        transit_tuples_reverse = [
            (row[6], row[0], dict(length=row[8], mode="walk"))
            for _, row in transit_nodes.iterrows()
        ]
        G.add_edges_from(transit_tuples_reverse)
        return cls(graph=G)
